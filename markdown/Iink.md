# 编译单元

每个cpp文件就是一个编译单元，每个cpp文件之间不知道对方的存在，编译器分别对每个cpp文件进行编译，生成相应的obj文件，然后链接器会将所有的obj文件进行链接，生成最终可执行文件。

# 内部链接与外部链接

```c++
a.cpp
void show();
int main()
{
	show();
	return 0;
}
```

```c++
b.cpp
#include<iostream>
void show()
{
	std::cout<<"hellowrold"<<endl;
}
```
那些编译单元(.cpp)中能向其他编译单元(.cpp)展示，提供其定义，让其他编译单元(.cpp)使用的的函数，变量就是外部链接，例如全局变量

而那些编译单元(.cpp)中不能向其他编译单元(.cpp)展示，提供其定义的函数，变量就是内部链接，例如static函数，inline函数等

## 编译单元：
当一个c或cpp文件在编译时，预处理器首先递归包含头文件，形成一个含有所有 必要信息的单个源文件，这个源文件就是一个编译单元。

## 内部连接：
如果一个名称对编译单元(.cpp)来说是局部的，在链接的时候其他的编译单元无法链接到它且不会与其它编译单元(.cpp)中的同样的名称相冲突。

## 外部连接：
如果一个名称对编译单元(.cpp)来说不是局部的，而在链接的时候其他的编译单元可以访问它，也就是说它可以和别的编译单元交互。

**为什么有时会出现aaa已在bbb中重定义的错误？**
答：你可能在不同的cpp中重复定义了一个具有外部链接的函数或变量，链接器在链接时找到了多个一样的函数或变量定义

**为什么有时会出现无法解析的外部符号？**
答：你可能只提供了函数或变量的声明，没有提供其定义，或者声明和定义的函数原型不一致，链接器没有找到其定义在哪里，所以在链接环节出现了无法解析的外部符号的错误

**为什么有的内联函数的定义需要写在头文件中呢?**
答：因为内链函数是内部链接的，如果你在b.cpp中定义这个函数，那么在a.cpp中即使有这个函数声明，但由于内链函数是内部链接的，所以b.cpp不会提供其定义,所以在链接时a.obj无法找到这个函数的定义，便会出现无法解析的外部符号的错误

**为什么对于模板，声明和定义都要写在一起呢？**
```c++
b.h
#pragma once
template<typename T>
class A
{
public:
    A(const T &t);
};
```

```c++
b.cpp
#include "b.h"
#include <iostream>

template<typename T>
A<T>::A(const T &t)
{
    std::cout << t << std::endl;
}
```

```c++
#include "b.h"

int main()
{  
    //A<int> a(5);
    return 0;
}
```

那么a.cpp中注释的那行代码能否正常运行呢？
答案是不能我们首先来分析一下编译器在编译a.cpp时，发现其缺少A<int>::a(const int& t)的定义而在编译器编译b.cpp时，由于每个编译单元是独立的，而模板只有被用到的时候才会被实例化，产生定义，b.cpp不知道a.cpp用了A<int>::a(const int& t)，所以它不会提供A<int>::a(const int& t)的定义，编译器不会有任何反应，这样在链接时a.obj无法找到A<int>::a(const int& t)的定义，就会出现无法解析的外部符号的错误

**宏是内部链接还是外部链接**
答：都不是，宏在预处理环节时就被替换掉了，而内部链接与外部链接是针对编译环节与链接环节而言的